# DirectX 11 Renderer
For this project I'm developing a renderer using the grahics API DirectX 11, here's an image of a 
PBR shaded scene with FXAA and SSAO enabled generated by the renderer.

![alt text](https://github.com/moeb15/Renderer/blob/main/Demos/PBR2_FXAA_SSAO.png)

At the moment, this is a high level overview of how a scene is rendered,

* A scene stores a vector of objects that derive from the base class Renderable, alongside a vector of point lights
* In the RenderScene method, the scene submits the Renderables to the renderer, afterwards it calls the Render function
with the camera, point lights, and directional lights view-projection matrix passed as paramters
* In the Renderer classes submission function, each Renderable is pushed into 2 of 3 queues,
transparent objects are pushed into the transparent render queue, opaque into the opaque render queue,
and each of them is pushed into the depth render queue
* In the render method we start by performing light culling, all point lights whose bounding sphere
that does not intersect with the cameras view frustum are disabled
* The initial render pass is the Z-Prepass, we then follow with another Depth Prepass 
from the shadow casting directional lights perspective
* Afterwards we have a shadow pass, in which a shadow map for the directional lights depth map is generated
* The next pass is the GBuffer Pass, we populate the GBuffer with the scenes colour, normals, view-space positions,
specular, roughness, and metallic values
* There is an optional post-processing pass, in which we can enable settings like blur, FXAA, and SSAO,
if post-processing is enabled we start by rendering the scene to a texture to peform any of the listed
effects, the texture is then rendered to a quad which covers the viewport, we can then return from the 
render method once this is done
* If post-processing is not enabled, we have 2 possible final rendering passes, the forward rendering pass 
and the deferred rendering pass, we can choose to enable one or the other

The following is what I'm currently working on implementing,

* Clustered forward and clustered deferred rendering
* Multithreading, at the moment I'm relying on the immediate context, I'd like to treat
the immediate context as a command queue, and have seperate deferred contexts and command lists
for each physical CPU core
* Fixing an issue with frustum culling, bounding volumes are not being drawn at proper positions
for imported glTF models despite using node transforms
* Fixing an issue with shadow mapping
* Fixing pbr and phong shader for deferred rendering pipeline